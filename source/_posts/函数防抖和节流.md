---
title: 函数防抖和节流
date: 2017-10-20 09:41:54
tags: javascript
categories: 前端
---
针对一些会频繁触发的事件如scroll、resize，如果正常绑定事件处理函数的话，有可能在很短的时间内多次连续触发事件，十分影响性能，因此针对这类事件要进行防抖动或者节流处理
<!--more-->
------
# 函数防抖

函数防抖是限制在下次函数调用之前必须等待一个时间间隔，实现的方法是将若干个函数调用合并成一次，并在给定的时间过去之后仅被调用一次。

```javascript
function debounce (fn, delay) {
  let timer = null
  return function () {
    let context = this
    let args = arguments
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}
```
```javascript
function foo () {
  console.log('scrolling...')
}
elem.addEventListener('scroll', debounce(foo, 2000))
```

当不希望非要等到事件停止触发后才执行，而是立刻执行函数，然后等到停止触发n秒后，才可以重新触发执行，可以增加一个immediate参数来设置是否要立即执行。

```javascript
function debounce (func, delay, immediate) {
  let timer = null
  return function () {
    let context = this
    let args = arguments
    if (timer) {
      clearTimeout(timer)
    }
    if (immediate) {
      // 根据距离上次触发操作时间是否到达delay来决定是否要现在执行函数
      let doNow = !timer
      // 每一次都重新设置timer，就是要保证每一次执行的至少delay秒后才可以执行
      timer = setTimeout(function(){
        timer = null
      },delay)
      // 立即执行
      if (doNow) {
        func.apply(context, args)
      }
    } else {
      timer = setTimetout(function(){
        func.apply(context, args)
      }, delay)
    }
  }
}
```

# 函数节流

节流是处理类似问题的另一种解决方案，节流函数允许一个函数在规定的时间内只执行一次，它和防抖最大的区别在于，节流函数不管时间触发有多频繁，都会保证在规定的时间内一定会执行一次真正的事件处理函数。

应用场景：比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次ajax请求，而不是在用户停下滚动操作时才去请求数据。

主要的实现方法有两种：
- 时间戳
- 定时器

时间戳实现
```javascript
function throttle (func, delay) {
  let prew = Data.now()
  return function () {
    let context = this
    let args = arguments
    let now = Data.now()
    if (now - prev >= delay) {
      func.apply(context, args)
      prev = Date.now()
    }
  }
}
```

当高频事件频繁触发时，如果给事件绑定函数与真正触发事件的间隔如果大于delay，第一次应该会立即执行，而后无论再怎么频繁触发事件，也都只是每delay秒才执行一次，而当最后一次事件触发完毕后，事件也不会再被执行了。

定时器实现
当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行,直到delay秒后，定时器执行函数，清空定时器，这样就可以设置下个定时器
```javascript
function  throttle (func, delay) {
  let timer = null
  return function () {
    let context = this
    let args = arguments
    if (!timer) {
      tiemr = setTimeout(function(){
        func.apply(context, args)
        timer = null
      }, delay)
    }
  }
}
```

可以结合时间戳和定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数。
```javascript
function throttle (func, delay) {
  let timer = null
  let startTime = Date.now()
  return function () {
    let curTime = Date.now()
    let remaining = delay - (curTime - startTime)
    let context = this
    let args = arguments

    clearTimeout(timer)
    if (remaining <= 0) {
      func.apply(context, args)
      startTime = Date.now()
    } else {
      timer = setTimeout(func, remaining)
    }
  }
}
```
需要在每个delay时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与delay来计算remaining，当remaining<=0时表示该执行函数了，如果还没到时间的话就设定在remaining时间后再触发。当然在remaining这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。

# 总结
防止一个事件频繁触发回调函数的方式：
- 防抖动：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。
- 节流：使得一定时间内只触发一次函数。
它和防抖动最大的区别就是，节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而防抖动只是在最后一次事件后才触发一次函数。
原理是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。
